# JavaScript面试题汇总

#### JavaScript基础

##### 1. javascript有哪些数据类型？有什么区别？

##### 2. 数组的常用方法？

##### 3. 对象的常用方法？

##### 4. 说说你对闭包的了解？以及闭包的使用场景？

##### 5. 说说你对原型、原型链的理解？有什么特点？

##### 6. 说说你对作用域链的理解？

##### 7. 说说你对this的理解？

##### 8. 说说new操作服具体做了什么工作？

##### 9. 说一说宏任务与微任务以及与Event-Loop？

从整体性来说：宏任务和微任务以及Event-Loop等概念主要描述的是javascript任务类型以及这种不同类型的任务在单线程下面是如何配合执行的，也可以理解为javascript执行任务的机制。

那么首先要从javascript是一个单线程的脚本语言说起。由于是单线程，那么在执行一行代码的时候，必然不会存在同时执行另一行代码的行为；或者说某行代码的执行若是相对耗时的话，后续的代码程序只能无条件等待。那么这样的代码执行方式会引发严重的类似于阻塞问题，比如前一段代码要从服务端获取数据，然后由于网络等原因造成结果返回延迟时间较久，那么后续的程序则无法及时完成。

为了解决类似的问题，javascript就有了异步事件的概念。比如发送一个网络请求，告诉主程序接收到数据后提醒我，然后这期间就可以执行其它的程序。但是，在数据到达后，js若正在执行其它程序，那么这些异步事件只能等待js空闲时才执行。

所以，引入宏任务和微任务来描述这种不同的任务类型，比如script整体脚本代码、setTimeout、setInterval、IO、UI交互等等这些都被认为是宏任务；而Promise.then、Object.observe、MutationObserver、process.nextTick（Node）这些都被认为是微任务。

既然这些不同的任务都划分为了宏任务和微任务，那么它们是如何配合执行的呢？ 这就引入了event-lopp的概念，即javascript事件循环机制：js将优先执行同步任务，将异步任务放入任务队列，当同步任务执行完成后，尝试清空当前任务产生的微任务队列；然后调用任务队列中的异步任务执行，当异步任务执行完毕后，同样尝试清空该任务产生的微任务队列。执行完毕后，进行下一个到来的宏任务，以此反复：

1. 首先，从scirpt脚本加载时，js主线程将同步任务推入执行栈中执行，将异步任务放入任务队列；
2. 其次，执行宏任务过程中如果遇到或产生微任务，就将它添加到微任务队列中；
3. 然后，当此宏任务执行完毕后，立即检查当前的微任务队列是否存在微任务；如果有则立即依次执行微任务队列中的所有微任务，并且执行完毕后清空当前的微任务队列。如果没有则直接进行下一步；
4. 当所有宏任务执行完毕后，开始检查渲染，一些GUI线程接管并渲染页面，比如宏任务中存在了操作dom的行为，即需要渲染
5. 最后渲染完毕后，js线程继续接管开始执行任务队列中的下一个宏任务，并以此反复。

上述即为Event-Loop执行机制，那么有哪些常见的宏任务和微任务呢？

###### **宏任务：**

|         任务          | 浏览器 | Node |
| :-------------------: | :----: | :--: |
|          I/O          |   ✅    |  ✅   |
|      setTimeout       |   ✅    |  ✅   |
|      setInterval      |   ✅    |  ✅   |
| requestAnimationFrame |   ✅    |  ❌   |
|     setImmediate      |   ❌    |  ✅   |

###### 微任务：

|                             任务                             | 浏览器 | Node |
| :----------------------------------------------------------: | :----: | :--: |
| [MutationObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver) |   ✅    |  ❌   |
|                  Promise.then/catch/finally                  |   ✅    |  ❌   |
|                       process.nextTick                       |   ❌    |  ✅   |

###### async/await

这里多说一句async/await，因为async/await本质上是Promise的一些封装，而Promise构造函数属于宏任务，then/catch/finally属于微任务，因此async/await与Promise类似：**async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于`new Promise`时传入的代码，await之后的代码都是在`promise.then`中的回调，属于微任务。**

参考文章：

* [宏任务、微任务与Event-Loop](https://juejin.cn/post/6844903657264136200#heading-9)
* [Node中的Event-Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick)

---

##### 10. 说一说防抖和节流？有什么区别？如何实现？

##### 11. 说一说JavaScript中的垃圾回收以及内存泄漏？

常用的垃圾回收方法：

1. 标记清除
2. 引用计数

常见的内存泄漏：

1. 意外的全局变量
2. 定时器操作dom导致dom的引用未释放
3. 闭包维持函数内部变量，导致变量无法释放
4. `addEventListener`事件不在监听的时候，未使用`removeEventListener`移除事件监听

---

##### 12. JavaScript的存储方式有哪些？有什么区别？分别的应用场景？

###### 一、存储方式

* Cookie
* localStorage
* sesstionStorage
* indexDB

###### 二、区别

这里主要说一下`cookie`、`localStorage`、`sessionStorage`三者的区别：

* **存储大小：**`cookie`的数据大小不能超过**4k**，`localStorage`和`sessionStorage`虽然也有存储大小限制，但是比`cookie`大的多，可以达到**5M**或者更大。
* **有效时间：**
* **数据与服务器之间的交互方式：**



#### ES6系列

##### 1. var、let以及const的区别以及使用场景？

* **作用域：**`let`和`const`声明一个块级作用域的局部变量或者常量。`var`声明的作用域是它当前的执行上下文及其闭包，即全局作用域内或者函数作用域内。块级作用域由`{}`包裹，`let`和`const`具有块级作用域，`var`不存在块级作用域；块级作用域解决了ES5遗留的两个问题：
  * 内层变量可能覆盖外层变量
  * 用来计数的循坏变量泄露为全局变量（注意：for循环变量声明处为父级作用域，循环体内为子级作用域）
* **变量提升：**使用`var`声明的变量将在任何代码执行前被创建，这被称为变量提升。这些变量的初始值为`undefined`。`let`和`const`没有变量提升，即变量只能在声明后使用，否则会报错。
* **全局属性：**`var`在全局作用域下声明的变量会作为其运行环境的全局对象的属性（浏览器全局对象window，Node全局对象为global），`let`和`const`却不会。
* **重复声明：**`var`声明变量时，可以重复声明变量；后声明的同名变量会覆盖之前的变量。`let`和`const`不允许重复声明变量。
* **暂时性死区：**在`let`和`const`变量声明之前，该变量都是不可用的，这在语法上称为**暂时性死区**。使用`var`声明的变量不存在暂时性死区。
* **初始值：**`let`和`var`都是声明变量，因此可以不置顶初始值；而`const`声明的是常量，因此必须指定初始值。

---

* 